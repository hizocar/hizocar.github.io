[
  {
    "objectID": "data_science_ingemat/presentacion.html",
    "href": "data_science_ingemat/presentacion.html",
    "title": "Presentando un proyecto",
    "section": "",
    "text": "Objetivo del Proyecto: Comienza con una visi√≥n general del proyecto y sus objetivos. Explica por qu√© se realiz√≥ el proyecto y cu√°l es su relevancia para la empresa.\n\n\n\nProblema a Resolver: Describe el problema que tu proyecto de ciencia de datos est√° tratando de resolver. Haz esto de una manera que sea comprensible para personas que no son expertas en el tema, utilizando ejemplos y analog√≠as simples cuando sea posible.\n\n\n\nRecopilaci√≥n de Datos: Explica c√≥mo y de d√≥nde obtuviste los datos para el proyecto.\n\n\nDescribe c√≥mo se prepararon los datos para el an√°lisis. Puedes mencionar t√©cnicas de limpieza de datos, pero evita entrar en demasiados detalles t√©cnicos.\n\n\n\nDescribe las t√©cnicas y algoritmos que utilizaste para desarrollar el modelo de ciencia de datos. Explica por qu√© elegiste esos enfoques y c√≥mo se relacionan con el problema que est√°s tratando de resolver. Intenta mantener la explicaci√≥n accesible y evita el uso de jerga t√©cnica tanto como sea posible.\n\n\n\n\nInterpretaci√≥n de Resultados: Presenta los resultados de tu an√°lisis de una manera f√°cil de entender. Utiliza gr√°ficos y tablas para visualizar los datos y destacar los hallazgos clave. Evita presentar demasiados n√∫meros crudos; en su lugar, trata de resumir y explicar los resultados de una manera que sea f√°cil de entender.\n\n\nExplica lo que los resultados significan para el negocio. ¬øQu√© acciones deber√≠a tomar la empresa bas√°ndose en estos resultados? ¬øC√≥mo ayudar√° esto a la empresa a alcanzar sus objetivos?\n\n\n\n\n\n\nResume los hallazgos clave de tu proyecto y c√≥mo estos hallazgos pueden beneficiar a la empresa.\n\n\n\nProporciona recomendaciones para los pr√≥ximos pasos. ¬øHay otras preguntas que podr√≠an explorarse en el futuro? ¬øC√≥mo puede la empresa implementar los resultados de tu proyecto?\n\n\n\n\nDeja tiempo para preguntas al final de la presentaci√≥n. Esto da a la audiencia la oportunidad de aclarar cualquier aspecto que no entienda y permite que se realicen preguntas m√°s profundas que pueden no ser adecuadas durante la presentaci√≥n principal.\nRecuerda, la clave es mantener el lenguaje simple y accesible, y tratar de relacionar todo con los objetivos y necesidades de la empresa. Tu meta es hacer que la audiencia comprenda el valor de tu trabajo, no impresionarlos con jerga t√©cnica."
  },
  {
    "objectID": "data_science_ingemat/presentacion.html#c√≥mo-presentar-un-proyecto-de-ciencias-de-datos",
    "href": "data_science_ingemat/presentacion.html#c√≥mo-presentar-un-proyecto-de-ciencias-de-datos",
    "title": "Presentando un proyecto",
    "section": "",
    "text": "Objetivo del Proyecto: Comienza con una visi√≥n general del proyecto y sus objetivos. Explica por qu√© se realiz√≥ el proyecto y cu√°l es su relevancia para la empresa.\n\n\n\nProblema a Resolver: Describe el problema que tu proyecto de ciencia de datos est√° tratando de resolver. Haz esto de una manera que sea comprensible para personas que no son expertas en el tema, utilizando ejemplos y analog√≠as simples cuando sea posible.\n\n\n\nRecopilaci√≥n de Datos: Explica c√≥mo y de d√≥nde obtuviste los datos para el proyecto.\n\n\nDescribe c√≥mo se prepararon los datos para el an√°lisis. Puedes mencionar t√©cnicas de limpieza de datos, pero evita entrar en demasiados detalles t√©cnicos.\n\n\n\nDescribe las t√©cnicas y algoritmos que utilizaste para desarrollar el modelo de ciencia de datos. Explica por qu√© elegiste esos enfoques y c√≥mo se relacionan con el problema que est√°s tratando de resolver. Intenta mantener la explicaci√≥n accesible y evita el uso de jerga t√©cnica tanto como sea posible.\n\n\n\n\nInterpretaci√≥n de Resultados: Presenta los resultados de tu an√°lisis de una manera f√°cil de entender. Utiliza gr√°ficos y tablas para visualizar los datos y destacar los hallazgos clave. Evita presentar demasiados n√∫meros crudos; en su lugar, trata de resumir y explicar los resultados de una manera que sea f√°cil de entender.\n\n\nExplica lo que los resultados significan para el negocio. ¬øQu√© acciones deber√≠a tomar la empresa bas√°ndose en estos resultados? ¬øC√≥mo ayudar√° esto a la empresa a alcanzar sus objetivos?\n\n\n\n\n\n\nResume los hallazgos clave de tu proyecto y c√≥mo estos hallazgos pueden beneficiar a la empresa.\n\n\n\nProporciona recomendaciones para los pr√≥ximos pasos. ¬øHay otras preguntas que podr√≠an explorarse en el futuro? ¬øC√≥mo puede la empresa implementar los resultados de tu proyecto?\n\n\n\n\nDeja tiempo para preguntas al final de la presentaci√≥n. Esto da a la audiencia la oportunidad de aclarar cualquier aspecto que no entienda y permite que se realicen preguntas m√°s profundas que pueden no ser adecuadas durante la presentaci√≥n principal.\nRecuerda, la clave es mantener el lenguaje simple y accesible, y tratar de relacionar todo con los objetivos y necesidades de la empresa. Tu meta es hacer que la audiencia comprenda el valor de tu trabajo, no impresionarlos con jerga t√©cnica."
  },
  {
    "objectID": "data_science_ingemat/modulo2/ARIMA_SARIMA_Tutorial.html",
    "href": "data_science_ingemat/modulo2/ARIMA_SARIMA_Tutorial.html",
    "title": "Quiz: Modelos ARIMA y SARIMA",
    "section": "",
    "text": "ARIMA es un acr√≥nimo que significa AutoRegressive Integrated Moving Average. Es una clase de modelos que explica una serie de tiempo dada en funci√≥n de sus propios valores pasados, es decir, su propia lags. Puede ser percibido como una regresi√≥n lineal de los datos pasados.\nLos componentes de los modelos ARIMA son:\n\nAR: Autoregression. Un modelo que utiliza la relaci√≥n dependiente entre una observaci√≥n y un n√∫mero de observaciones rezagadas (lagged observations).\nI: Integrated. El uso de la diferenciaci√≥n de las observaciones en bruto (por ejemplo, restar una observaci√≥n de una observaci√≥n en el paso de tiempo anterior) para hacer que la serie de tiempo sea estacionaria.\nMA: Moving Average. Un modelo que utiliza la dependencia entre una observaci√≥n y un error residual de un modelo de media m√≥vil aplicado a observaciones rezagadas.\n\nUn modelo ARIMA se denota como ARIMA(p,d,q) donde:\n\np es el n√∫mero de t√©rminos autorregresivos (AR part). Permite incorporar el efecto de los valores pasados en nuestro modelo.\nd es el n√∫mero de diferencias no estacionales necesarias para la estacionariedad.\nq es el n√∫mero de errores de pron√≥stico rezagados en la ecuaci√≥n de predicci√≥n (MA part)."
  },
  {
    "objectID": "data_science_ingemat/modulo2/ARIMA_SARIMA_Tutorial.html#modelos-arima",
    "href": "data_science_ingemat/modulo2/ARIMA_SARIMA_Tutorial.html#modelos-arima",
    "title": "Quiz: Modelos ARIMA y SARIMA",
    "section": "",
    "text": "ARIMA es un acr√≥nimo que significa AutoRegressive Integrated Moving Average. Es una clase de modelos que explica una serie de tiempo dada en funci√≥n de sus propios valores pasados, es decir, su propia lags. Puede ser percibido como una regresi√≥n lineal de los datos pasados.\nLos componentes de los modelos ARIMA son:\n\nAR: Autoregression. Un modelo que utiliza la relaci√≥n dependiente entre una observaci√≥n y un n√∫mero de observaciones rezagadas (lagged observations).\nI: Integrated. El uso de la diferenciaci√≥n de las observaciones en bruto (por ejemplo, restar una observaci√≥n de una observaci√≥n en el paso de tiempo anterior) para hacer que la serie de tiempo sea estacionaria.\nMA: Moving Average. Un modelo que utiliza la dependencia entre una observaci√≥n y un error residual de un modelo de media m√≥vil aplicado a observaciones rezagadas.\n\nUn modelo ARIMA se denota como ARIMA(p,d,q) donde:\n\np es el n√∫mero de t√©rminos autorregresivos (AR part). Permite incorporar el efecto de los valores pasados en nuestro modelo.\nd es el n√∫mero de diferencias no estacionales necesarias para la estacionariedad.\nq es el n√∫mero de errores de pron√≥stico rezagados en la ecuaci√≥n de predicci√≥n (MA part)."
  },
  {
    "objectID": "data_science_ingemat/modulo2/ARIMA_SARIMA_Tutorial.html#modelos-sarima",
    "href": "data_science_ingemat/modulo2/ARIMA_SARIMA_Tutorial.html#modelos-sarima",
    "title": "Quiz: Modelos ARIMA y SARIMA",
    "section": "Modelos SARIMA",
    "text": "Modelos SARIMA\nLos modelos SARIMA (Seasonal Autoregressive Integrated Moving Average) son una extensi√≥n de los modelos ARIMA que soportan directamente las series de tiempo univariadas con un componente estacional.\nUn modelo SARIMA se denota como SARIMA(p,d,q)(P,D,Q)m donde:\n\np, d, q son los par√°metros del modelo ARIMA para las tendencias no estacionales.\nP, D, Q son los par√°metros del modelo ARIMA para las tendencias estacionales.\nm se refiere al n√∫mero de periodos en cada temporada."
  },
  {
    "objectID": "data_science_ingemat/modulo2/ARIMA_SARIMA_Tutorial.html#ejemplo-en-python",
    "href": "data_science_ingemat/modulo2/ARIMA_SARIMA_Tutorial.html#ejemplo-en-python",
    "title": "Quiz: Modelos ARIMA y SARIMA",
    "section": "Ejemplo en Python",
    "text": "Ejemplo en Python\nAqu√≠ hay un ejemplo de c√≥mo ajustar un modelo ARIMA y SARIMA a una serie de tiempo en Python usando la biblioteca statsmodels.\nimport pandas as pd\nfrom statsmodels.tsa.arima.model import ARIMA\nfrom statsmodels.tsa.statespace.sarimax import SARIMAX\n\n# Cargar datos\nseries = pd.read_csv('your_data.csv', header=0, index_col=0, parse_dates=True, squeeze=True)\n\n# Ajustar modelo ARIMA\nmodel_arima = ARIMA(series, order=(5,1,0))\nmodel_arima_fit = model_arima.fit(disp=0)\nprint(model_arima_fit.summary())\n\n# Ajustar modelo SARIMA\nmodel_sarima = SARIMAX(series, order=(1, 1, 1), seasonal_order=(1, 1, 1, 12))\nmodel_sarima_fit = model_sarima.fit(disp=False)\nprint(model_sarima_fit.summary())\nPor favor, reemplace 'your_data.csv' con la ruta a su archivo de datos. Los par√°metros (5,1,0) y (1, 1, 1, 12) son solo ejemplos y deben ser ajustados a sus datos espec√≠ficos."
  },
  {
    "objectID": "data_science_ingemat/modulo2/ARIMA_SARIMA_Tutorial.html#detalles-adicionales-sobre-los-modelos-arima",
    "href": "data_science_ingemat/modulo2/ARIMA_SARIMA_Tutorial.html#detalles-adicionales-sobre-los-modelos-arima",
    "title": "Quiz: Modelos ARIMA y SARIMA",
    "section": "Detalles adicionales sobre los modelos ARIMA",
    "text": "Detalles adicionales sobre los modelos ARIMA\nLos modelos ARIMA son aplicados en algunos casos donde los datos muestran evidencia de no estacionariedad, donde una etapa inicial de diferenciaci√≥n (correspondiente al componente ‚ÄòI‚Äô en el modelo) puede ser aplicada una o m√°s veces para eliminar la tendencia no estacionaria.\nEl componente AR del modelo ARIMA indica que la variable evolutiva de inter√©s es regresada en sus propios valores rezagados, es decir, anteriores. Por ejemplo, si p es 5, los predictores para x(t) ser√°n x(t-1)‚Ä¶.x(t-5).\nEl componente MA del modelo ARIMA indica que el error de regresi√≥n es en realidad una combinaci√≥n lineal de t√©rminos de error cuyos valores ocurrieron contempor√°neamente y en varios momentos en el pasado.\nEl componente I del modelo ARIMA indica que los datos se han diferenciado al menos una vez para hacer la serie estacionaria."
  },
  {
    "objectID": "data_science_ingemat/modulo2/ARIMA_SARIMA_Tutorial.html#detalles-adicionales-sobre-los-modelos-sarima",
    "href": "data_science_ingemat/modulo2/ARIMA_SARIMA_Tutorial.html#detalles-adicionales-sobre-los-modelos-sarima",
    "title": "Quiz: Modelos ARIMA y SARIMA",
    "section": "Detalles adicionales sobre los modelos SARIMA",
    "text": "Detalles adicionales sobre los modelos SARIMA\nLos modelos SARIMA a√±aden una capa adicional de complejidad al modelado de series temporales. Estos modelos incorporan elementos de estacionalidad tanto en el componente AR como en el MA del modelo. Esto significa que el modelo no s√≥lo considera las relaciones de los datos consigo mismo (AR), los errores (MA) y las diferencias para la estacionariedad (I), sino que tambi√©n tiene en cuenta la estacionalidad de los datos.\nEl componente SAR del modelo SARIMA indica que la serie temporal tiene correlaciones estacionales autorregresivas. Por ejemplo, si P es 2, los predictores para x(t) ser√°n x(t-12) y x(t-24) si la serie es mensual.\nEl componente SMA del modelo SARIMA indica que la serie temporal tiene correlaciones estacionales de media m√≥vil. Por ejemplo, si Q es 1, los predictores para x(t) ser√°n los errores en los periodos t-12 y t-24 si la serie es mensual.\nEl componente SI del modelo SARIMA indica que los datos se han diferenciado al menos una vez para eliminar la estacionalidad.\nEl par√°metro m en el modelo SARIMA se refiere al n√∫mero de periodos por temporada, y es fundamental para modelar correctamente la estacionalidad. Por ejemplo, m ser√≠a 4 para datos trimestrales, 12 para datos mensuales, o 7 para datos diarios si se espera una estacionalidad semanal.\n\nQUIZ:\nA continuaci√≥n responde el siguiente quiz: https://forms.gle/aA9Mx1D5BNvhb1SL7"
  },
  {
    "objectID": "data_science_ingemat/modulo2/complemento.html",
    "href": "data_science_ingemat/modulo2/complemento.html",
    "title": "Temas complementarios",
    "section": "",
    "text": "Los modelos ARIMA y SARIMA son una extensi√≥n de los modelos de regresi√≥n lineal que se utilizan para modelar series de tiempo no estacionarias. Estos modelos pueden capturar una amplia gama de estructuras de dependencia temporal.\n\nLectura recomendada: ARIMA model as a tool in forecasting the variables: A case study\n\n\n\n\nLos modelos de volatilidad estoc√°stica son √∫tiles para modelar series de tiempo financieras, donde la volatilidad (la varianza de los errores) puede cambiar con el tiempo.\n\nLectura recomendada: Stochastic Volatility Modeling\n\n\n\n\nEstos modelos permiten que los par√°metros de un modelo de regresi√≥n cambien en diferentes ‚Äúreg√≠menes‚Äù o estados del mundo.\n\nLectura recomendada: A new approach to the economic analysis of nonstationary time series and the business cycle\n\n\n\n\nLos modelos de espacio de estados son una clase muy general de modelos de series de tiempo que incluyen modelos ARIMA y muchos otros como casos especiales. El filtro de Kalman es un algoritmo que se utiliza para estimar las variables latentes en estos modelos.\n\nLectura recomendada: Time Series Analysis by State Space Methods\n\n\n\n\nEstos modelos permiten analizar varias series de tiempo a la vez, capturando las interdependencias entre las series.\n\nLectura recomendada: Applied Multivariate Time Series Analysis: Foundations and Trends in Econometrics\n\n\n\n\nEl aprendizaje autom√°tico ofrece una serie de t√©cnicas que pueden ser √∫tiles para modelar series de tiempo, especialmente cuando se dispone de grandes cantidades de datos.\n\nLectura recomendada: Deep Learning for Time Series Forecasting"
  },
  {
    "objectID": "data_science_ingemat/modulo2/complemento.html#modelos-arima-y-sarima",
    "href": "data_science_ingemat/modulo2/complemento.html#modelos-arima-y-sarima",
    "title": "Temas complementarios",
    "section": "",
    "text": "Los modelos ARIMA y SARIMA son una extensi√≥n de los modelos de regresi√≥n lineal que se utilizan para modelar series de tiempo no estacionarias. Estos modelos pueden capturar una amplia gama de estructuras de dependencia temporal.\n\nLectura recomendada: ARIMA model as a tool in forecasting the variables: A case study"
  },
  {
    "objectID": "data_science_ingemat/modulo2/complemento.html#modelos-de-volatilidad-estoc√°stica",
    "href": "data_science_ingemat/modulo2/complemento.html#modelos-de-volatilidad-estoc√°stica",
    "title": "Temas complementarios",
    "section": "",
    "text": "Los modelos de volatilidad estoc√°stica son √∫tiles para modelar series de tiempo financieras, donde la volatilidad (la varianza de los errores) puede cambiar con el tiempo.\n\nLectura recomendada: Stochastic Volatility Modeling"
  },
  {
    "objectID": "data_science_ingemat/modulo2/complemento.html#modelos-de-regresi√≥n-con-cambios-de-r√©gimen",
    "href": "data_science_ingemat/modulo2/complemento.html#modelos-de-regresi√≥n-con-cambios-de-r√©gimen",
    "title": "Temas complementarios",
    "section": "",
    "text": "Estos modelos permiten que los par√°metros de un modelo de regresi√≥n cambien en diferentes ‚Äúreg√≠menes‚Äù o estados del mundo.\n\nLectura recomendada: A new approach to the economic analysis of nonstationary time series and the business cycle"
  },
  {
    "objectID": "data_science_ingemat/modulo2/complemento.html#modelos-de-espacio-de-estados-y-filtros-de-kalman",
    "href": "data_science_ingemat/modulo2/complemento.html#modelos-de-espacio-de-estados-y-filtros-de-kalman",
    "title": "Temas complementarios",
    "section": "",
    "text": "Los modelos de espacio de estados son una clase muy general de modelos de series de tiempo que incluyen modelos ARIMA y muchos otros como casos especiales. El filtro de Kalman es un algoritmo que se utiliza para estimar las variables latentes en estos modelos.\n\nLectura recomendada: Time Series Analysis by State Space Methods"
  },
  {
    "objectID": "data_science_ingemat/modulo2/complemento.html#modelos-de-series-de-tiempo-multivariadas",
    "href": "data_science_ingemat/modulo2/complemento.html#modelos-de-series-de-tiempo-multivariadas",
    "title": "Temas complementarios",
    "section": "",
    "text": "Estos modelos permiten analizar varias series de tiempo a la vez, capturando las interdependencias entre las series.\n\nLectura recomendada: Applied Multivariate Time Series Analysis: Foundations and Trends in Econometrics"
  },
  {
    "objectID": "data_science_ingemat/modulo2/complemento.html#modelos-de-series-de-tiempo-con-machine-learning",
    "href": "data_science_ingemat/modulo2/complemento.html#modelos-de-series-de-tiempo-con-machine-learning",
    "title": "Temas complementarios",
    "section": "",
    "text": "El aprendizaje autom√°tico ofrece una serie de t√©cnicas que pueden ser √∫tiles para modelar series de tiempo, especialmente cuando se dispone de grandes cantidades de datos.\n\nLectura recomendada: Deep Learning for Time Series Forecasting"
  },
  {
    "objectID": "data_science_ingemat/modulo2/introduccion.html",
    "href": "data_science_ingemat/modulo2/introduccion.html",
    "title": "Tema 1: Introducci√≥n",
    "section": "",
    "text": "Introducci√≥n a las Series de Tiempo\nUna serie de tiempo es una secuencia de observaciones tomadas secuencialmente en el tiempo. Es una herramienta esencial en el an√°lisis de datos temporales y se utiliza en muchos campos, como la econom√≠a, las ciencias sociales, la f√≠sica, y la ingenier√≠a.\n\nDefinici√≥n Formal\nFormalmente, una serie de tiempo puede ser vista como un conjunto de puntos de datos indexados (o listados o graficados) en el orden del tiempo. Generalmente, una serie de tiempo se representa como:\nX = {X1, X2,..., Xt,..., Xn}\ndonde Xt representa la observaci√≥n en el tiempo t.\n\n\nAplicaciones de las Series de Tiempo\nLas series de tiempo se utilizan en una amplia variedad de aplicaciones, incluyendo:\n\nEconom√≠a: para el an√°lisis de indicadores econ√≥micos, como el producto interno bruto, la inflaci√≥n, las tasas de desempleo, etc.\nFinanzas: para el seguimiento y la predicci√≥n de los precios de las acciones, las tasas de inter√©s, y otros indicadores financieros.\nMeteorolog√≠a: para predecir el clima y los patrones clim√°ticos.\nCiencias de la Salud: para rastrear la propagaci√≥n de enfermedades o la eficacia de un tratamiento a lo largo del tiempo.\n\n\n\nClasificaci√≥n de las Series de Tiempo\nLas series de tiempo pueden ser clasificadas de acuerdo a su estructura en:\n\nSeries de Tiempo Estacionarias: Estas series tienen propiedades que no dependen del tiempo. En otras palabras, poseen una media y una varianza constantes a lo largo del tiempo.\nSeries de Tiempo No Estacionarias: Estas series muestran tendencias y/o patrones estacionales. No tienen una media y/o varianza constantes a lo largo del tiempo.\nSeries de Tiempo Estacionales: Estas son un tipo especial de series no estacionarias que exhiben una tendencia estacional, es decir, un patr√≥n que se repite en intervalos de tiempo espec√≠ficos."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "\nHi üëã, I‚Äôm Sebasti√°n Az√≥car\n",
    "section": "",
    "text": "Hi üëã, I‚Äôm Sebasti√°n Az√≥car\n\n\nData Scientist and Teacher\n\n\n\n\nPerfil\n\n\n\nüëã Hi there, I‚Äôm a Mathematical Engineer and hold a Master‚Äôs degree in Data Science\nüè† I‚Äôm currently living in Santiago, Chile.\nüåê I love traveling and visiting different countries.\nüìö I‚Äôm always learning and have a special interest in data analysis.\nüì´ How to reach me: hizocar@gmail.com\n\n\nConnect with me:\n\n\n  \n\n\nLanguages:\n\n\n           \n     \n\nML and Data Analysis:\n\n\n              \n\nCloud:"
  },
  {
    "objectID": "machine_learning_egei/class1.html",
    "href": "machine_learning_egei/class1.html",
    "title": "Class1: Different types of Data",
    "section": "",
    "text": "In the field of data science, we often talk about different types of data. Understanding these types is crucial for proper data analysis and interpretation. Here are some of the most common types of data:\nIn Python, we have several data types that are commonly used. Here are some of them with examples:\nPython has a variety of operators that can be used with different data types. Here are some examples:"
  },
  {
    "objectID": "machine_learning_egei/class1.html#python-data-types-exercises",
    "href": "machine_learning_egei/class1.html#python-data-types-exercises",
    "title": "Class1: Different types of Data",
    "section": "Python Data Types: Exercises",
    "text": "Python Data Types: Exercises\n\n# Exercise 1: Working with integers and floats\nnum1 = 10\nnum2 = 3\n\n# Addition\nprint('Addition:', num1 + num2)\n\n# Subtraction\nprint('Subtraction:', num1 - num2)\n\n# Multiplication\nprint('Multiplication:', num1 * num2)\n\n# Division\nprint('Division:', num1 / num2)\n\n# Floor Division\nprint('Floor Division:', num1 // num2)\n\n# Modulus\nprint('Modulus:', num1 % num2)\n\n# Exponentiation\nprint('Exponentiation:', num1 ** num2)\n\nAddition: 13\nSubtraction: 7\nMultiplication: 30\nDivision: 3.3333333333333335\nFloor Division: 3\nModulus: 1\nExponentiation: 1000\n\n\n\n# Exercise 2: Working with strings\nstr1 = 'Hello'\nstr2 = 'World'\n\n# String concatenation\nprint('Concatenation:', str1 + ' ' + str2)\n\n# String repetition\nprint('Repetition:', str1 * 3)\n\n# String slicing\nprint('Slicing:', str1[1:4])\n\n# String length\nprint('Length:', len(str1))\n\nConcatenation: Hello World\nRepetition: HelloHelloHello\nSlicing: ell\nLength: 5\n\n\n\n# Exercise 3: Working with lists\nlist1 = [1, 2, 3, 4, 5]\n\n# Accessing elements\nprint('First element:', list1[0])\nprint('Last element:', list1[-1])\n\n# List slicing\nprint('Slicing:', list1[1:4])\n\n# List length\nprint('Length:', len(list1))\n\n# Adding elements\nlist1.append(6)\nprint('After adding an element:', list1)\n\n# Removing elements\nlist1.remove(1)\nprint('After removing an element:', list1)\n\nFirst element: 1\nLast element: 5\nSlicing: [2, 3, 4]\nLength: 5\nAfter adding an element: [1, 2, 3, 4, 5, 6]\nAfter removing an element: [2, 3, 4, 5, 6]\n\n\n\n# Exercise 4: Working with dictionaries\ndict1 = {'name': 'John', 'age': 30, 'city': 'New York'}\n\n# Accessing elements\nprint('Name:', dict1['name'])\nprint('Age:', dict1['age'])\n\n# Adding elements\ndict1['job'] = 'Engineer'\nprint('After adding an element:', dict1)\n\n# Removing elements\ndel dict1['age']\nprint('After removing an element:', dict1)\n\nName: John\nAge: 30\nAfter adding an element: {'name': 'John', 'age': 30, 'city': 'New York', 'job': 'Engineer'}\nAfter removing an element: {'name': 'John', 'city': 'New York', 'job': 'Engineer'}"
  },
  {
    "objectID": "machine_learning_egei/class1.html#python-functions",
    "href": "machine_learning_egei/class1.html#python-functions",
    "title": "Class1: Different types of Data",
    "section": "Python Functions",
    "text": "Python Functions\nIn Python, a function is a block of reusable code that performs a specific task. Functions help break our program into smaller and modular chunks, making it organized and manageable. They also prevent repetition and make the code reusable.\nHere‚Äôs the basic syntax of a Python function:\ndef function_name(parameters):\n    \"\"\"docstring\"\"\"\n    statement(s)\n\nThe def keyword is a statement for defining a function in Python.\nfunction_name is a unique identifier for the function.\nparameters (arguments) through which we pass values to a function. These are optional.\nA colon (:) to mark the end of the function header.\nOptional documentation string (docstring) to describe what the function does.\nOne or more valid python statements that make up the function body. Statements must have the same indentation level (usually 4 spaces).\nAn optional return statement to return a value from the function.\n\n\n# Example of a Python function\n\ndef greet(name):\n    \"\"\"\n    This function greets the person passed in as a parameter\n    \"\"\"\n    print(f'Hello, {name}. Good morning!')\n\n# Calling the function\ngreet('John')\n\nHello, John. Good morning!\n\n\n\n# Example of a Python function with a return statement\n\ndef add_numbers(num1, num2):\n    \"\"\"\n    This function adds the two numbers passed in as parameters\n    \"\"\"\n    return num1 + num2\n\n# Calling the function and printing the result\nresult = add_numbers(5, 3)\nprint(f'The sum is {result}')\n\nThe sum is 8"
  },
  {
    "objectID": "machine_learning_egei/class1.html#exercises",
    "href": "machine_learning_egei/class1.html#exercises",
    "title": "Class1: Different types of Data",
    "section": "Exercises",
    "text": "Exercises\n\nExercise 1: Data Types\nGiven the following variables, convert each one to a different data type:\nnum = '123'\nstr_num = 456\nConvert num to an integer and str_num to a string. Print the new variables and their types.\n\n\nExercise 2: Functions\nWrite a function named calculate_average that takes a list of numbers as a parameter and returns their average.\nThen, call your function with the list [1, 2, 3, 4, 5] and print the result.\n\n\nExercise 3: Lists and Dictionaries\nGiven the following list of dictionaries:\ndata = [\n    {'name': 'John', 'age': 30, 'job': 'Engineer'},\n    {'name': 'Anna', 'age': 27, 'job': 'Doctor'},\n    {'name': 'Mike', 'age': 35, 'job': 'Artist'}\n]\nWrite a function named get_ages that takes the list as a parameter and returns a list of all ages. Then, call your function with the data list and print the result."
  },
  {
    "objectID": "introduction_to_python/classes.html",
    "href": "introduction_to_python/classes.html",
    "title": "Classes",
    "section": "",
    "text": "Class 1: Getting to know python |"
  },
  {
    "objectID": "introduction_to_python/class1.html",
    "href": "introduction_to_python/class1.html",
    "title": "Class 1: Getting to Know Python",
    "section": "",
    "text": "Python is a high-level, interpreted programming language known for its readability and simplicity. It supports multiple programming paradigms, including procedural, object-oriented, and functional programming. Python is widely used in data analysis, web development, machine learning, and artificial intelligence. Its extensive library support and vibrant community make it a popular choice for both beginners and experienced developers.\nHere is a simple example of Python code that takes an input and produces an output:\n# Input\nname = input('What is your name? ')\n\n# Output\nprint(f'Hello, {name}!')"
  },
  {
    "objectID": "introduction_to_python/class1.html#data-types-in-python",
    "href": "introduction_to_python/class1.html#data-types-in-python",
    "title": "Class 1: Getting to Know Python",
    "section": "Data Types in Python",
    "text": "Data Types in Python\nPython has several built-in data types. Here are some of the most common ones:\n\nIntegers (int): Whole numbers, such as 3, 4, or 100.\nFloating point numbers (float): Numbers with a decimal point, such as 2.3 or 4.6.\nStrings (str): Sequences of characters, such as ‚Äòhello‚Äô or ‚Äòpython‚Äô.\nBooleans (bool): True or false values.\n\nLet‚Äôs see some examples:\n\n# Integer\nx = 10\nprint(type(x))\n\n# Float\ny = 3.14\nprint(type(y))\n\n# String\nz = 'Hello, Python!'\nprint(type(z))\n\n# Boolean\nw = True\nprint(type(w))"
  },
  {
    "objectID": "introduction_to_python/class1.html#lists-in-python",
    "href": "introduction_to_python/class1.html#lists-in-python",
    "title": "Class 1: Getting to Know Python",
    "section": "Lists in Python",
    "text": "Lists in Python\nA list in Python is an ordered collection of items that can be of any type. Lists are very flexible and can be modified after they are created (they are mutable).\nHere is an example of a list:\n\n# List of integers\nnumbers = [1, 2, 3, 4, 5]\nprint(numbers)\n\n# List of different types\nmixed = [1, 'two', 3.0, True]\nprint(mixed)"
  },
  {
    "objectID": "introduction_to_python/class1.html#dictionaries-in-python",
    "href": "introduction_to_python/class1.html#dictionaries-in-python",
    "title": "Class 1: Getting to Know Python",
    "section": "Dictionaries in Python",
    "text": "Dictionaries in Python\nA dictionary in Python is an unordered collection of items. Each item in a dictionary has a key and a corresponding value. Dictionaries are mutable, meaning they can be changed after they are created.\nHere is an example of a dictionary:\n\n# Dictionary\nperson = {\n    'name': 'John',\n    'age': 30,\n    'is_married': True\n}\nprint(person)"
  },
  {
    "objectID": "introduction_to_python/class1.html#comparing-lists-and-dictionaries",
    "href": "introduction_to_python/class1.html#comparing-lists-and-dictionaries",
    "title": "Class 1: Getting to Know Python",
    "section": "Comparing Lists and Dictionaries",
    "text": "Comparing Lists and Dictionaries\nLists and dictionaries are both versatile data structures in Python, but they are used in different scenarios.\nLists are ordered collections of items, and they are best when the order of items matters. You can use lists when you have a collection of items that you want to keep in a specific order, or when you want to easily add or remove items from the collection.\nDictionaries are unordered collections of key-value pairs, and they are best when you need to associate values with keys, so you can look them up efficiently by key. Dictionaries are ideal for data that is labeled, where each item can be accessed by a unique key (like a product code or name).\nLet‚Äôs see some examples:\n\n# List example\nfruits = ['apple', 'banana', 'cherry']\nprint(fruits)\n\n# Add an item to the list\nfruits.append('date')\nprint(fruits)\n\n# Dictionary example\nfruit_colors = {\n    'apple': 'red',\n    'banana': 'yellow',\n    'cherry': 'red'\n}\nprint(fruit_colors)\n\n# Add an item to the dictionary\nfruit_colors['date'] = 'brown'\nprint(fruit_colors)\n\nIt is possible to convert a list to a dictionary and vice versa, but the way you do it depends on the structure of your data.\nFor example, if you have a list of pairs, you can convert it to a dictionary using the dict() function. And if you have a dictionary, you can convert it to a list of pairs using the items() method.\nLet‚Äôs see some examples:\n\n# List of pairs\npairs = [('one', 1), ('two', 2), ('three', 3)]\n\n# Convert list to dictionary\ndict_from_list = dict(pairs)\nprint(dict_from_list)\n\n# Dictionary\ndictionary = {'one': 1, 'two': 2, 'three': 3}\n\n# Convert dictionary to list\nlist_from_dict = list(dictionary.items())\nprint(list_from_dict)"
  },
  {
    "objectID": "introduction_to_python/class1.html#operations-and-methods-in-python",
    "href": "introduction_to_python/class1.html#operations-and-methods-in-python",
    "title": "Class 1: Getting to Know Python",
    "section": "Operations and Methods in Python",
    "text": "Operations and Methods in Python\nIn Python, an operation is an action that is carried out on one or more values. For example, the + operation adds two numbers together, and the * operation multiplies them.\nA method is a function that is associated with a particular type of object. For example, the count method can be used on a list to count the number of times a particular value appears in the list, and the upper method can be used on a string to convert all the characters to uppercase.\nThe len function is a built-in Python function that returns the length of a sequence, such as a list or a string.\nLet‚Äôs see some examples:\n\n# Operations\nprint(3 + 4)  # Addition\nprint(3 * 4)  # Multiplication\n\n# Methods\nnumbers = [1, 2, 3, 2, 1]\nprint(numbers.count(2))  # Count method\n\ntext = 'hello'\nprint(text.upper())  # Upper method\n\n# Len function\nprint(len(numbers))  # Length of a list\nprint(len(text))  # Length of a string"
  },
  {
    "objectID": "introduction_to_python/class1.html#combining-different-data-types-with-and",
    "href": "introduction_to_python/class1.html#combining-different-data-types-with-and",
    "title": "Class 1: Getting to Know Python",
    "section": "Combining Different Data Types with + and *",
    "text": "Combining Different Data Types with + and *\nIn Python, the + and * operators can be used with different types of data, but the behavior can be different depending on the types of the operands.\nWhen used with integers (int), the + operator performs addition and the * operator performs multiplication.\nWhen used with strings (str), the + operator concatenates the strings, and the * operator repeats the string a certain number of times.\nHowever, trying to use + or * with an integer and a string will result in a TypeError.\nLet‚Äôs see some examples:\n\n# Addition with integers\nprint(3 + 4)\n\n# Multiplication with integers\nprint(3 * 4)\n\n# Concatenation with strings\nprint('hello' + 'world')\n\n# Repetition with strings\nprint('hello' * 3)\n\n# Trying to add an integer and a string\ntry:\n    print(3 + 'hello')\nexcept TypeError as e:\n    print(e)\n\n# Trying to multiply an integer and a string\ntry:\n    print(3 * 'hello')\nexcept TypeError as e:\n    print(e)\n\n7\n12\nhelloworld\nhellohellohello\nunsupported operand type(s) for +: 'int' and 'str'\nhellohellohello"
  },
  {
    "objectID": "introduction_to_python/class1.html#libraries-in-python",
    "href": "introduction_to_python/class1.html#libraries-in-python",
    "title": "Class 1: Getting to Know Python",
    "section": "Libraries in Python",
    "text": "Libraries in Python\nIn Python, a library is a collection of modules, which are files containing Python code that define functions, classes, and variables that you can use once the module is imported.\nPython comes with a standard library that includes many useful modules, and there are also many third-party libraries available that provide additional functionality.\nYou can import a module using the import statement. Once a module is imported, you can use its functions and variables by prefixing them with the module name and a dot.\nIf a library is not installed, you can install it using the pip tool, which is the package installer for Python.\nLet‚Äôs see some examples:\n\n# Importing a module from the standard library\nimport math\n\n# Using a function from the math module\nprint(math.sqrt(16))\n\n# Note: The following code is commented out because it requires user interaction and might not work in this notebook interface.\n# But you can run it in your local Python environment.\n\n# Installing a third-party library (uncomment to run)\n# !pip install numpy\n\n4.0\n\n\nIf you only need a specific function from a module, you can import just that function using the from ... import ... statement. This allows you to use the function directly without prefixing it with the module name.\nLet‚Äôs see an example:\n\n# Importing a specific function from the math module\nfrom math import sqrt\n\n# Using the function directly\nprint(sqrt(16))\n\n4.0"
  },
  {
    "objectID": "introduction_to_python/class1.html#google-colab",
    "href": "introduction_to_python/class1.html#google-colab",
    "title": "Class 1: Getting to Know Python",
    "section": "Google Colab",
    "text": "Google Colab\nGoogle Colab is a cloud-based Python development environment that provides a platform for anyone to write and execute Python code through the browser. It is especially useful for machine learning, data analysis, and education.\n\nAdvantages\n\nNo setup required\nFree access to GPUs\nEasy sharing\n\nWhether you‚Äôre a student, a data scientist, or an AI researcher, Colab can make your work easier. You can write and execute code, save and share your analyses, and access powerful computing resources, all for free from your browser.\n\n\nDisadvantages\n\nInternet connection is required\nLimited resources\n\nDespite its advantages, Google Colab does have some limitations. It requires an internet connection to save and run notebooks, and the available resources (RAM and disk space) are limited.\nTo start a new notebook in Google Colab, you can follow this link."
  },
  {
    "objectID": "introduction_to_python/class1.html#exercises",
    "href": "introduction_to_python/class1.html#exercises",
    "title": "Class 1: Getting to Know Python",
    "section": "Exercises",
    "text": "Exercises\n\nData Types: Write a Python function that takes two inputs, determines their data types, and returns a message indicating the data type of each input.\nList Operations: Given a list of numbers, write a Python function that returns a new list containing the square of each number. Use a loop in your solution.\nDictionary Operations: Write a Python function that takes a dictionary and a key as input, checks if the key is in the dictionary, and returns a message indicating whether the key was found.\nString Methods: Write a Python function that takes a string as input and returns a new string with the first letter of each word capitalized.\nLibrary Usage: Use the math library to write a Python function that takes a number as input and returns the square root of the number."
  },
  {
    "objectID": "personal/academica.html",
    "href": "personal/academica.html",
    "title": "Academic Experience",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "machine_learning_egei/classes.html",
    "href": "machine_learning_egei/classes.html",
    "title": "Classes",
    "section": "",
    "text": "Class 1: Different type of Data |"
  },
  {
    "objectID": "data_science_ingemat/programa.html",
    "href": "data_science_ingemat/programa.html",
    "title": "Programa",
    "section": "",
    "text": "Objetivos Generales:\n\nDesarrollar habilidades avanzadas en ciencia de datos aplicadas en Python.\nFamiliarizar a los estudiantes con t√©cnicas avanzadas de aprendizaje autom√°tico.\nCapacitar a los estudiantes en el uso de herramientas avanzadas para el an√°lisis de datos en tiempo real.\nPromover la capacidad de los estudiantes para aplicar t√©cnicas de an√°lisis de datos en problemas del mundo real.\n\n\n\nM√≥dulo 1: Sistemas de Recomendaci√≥n\n\nIntroducci√≥n a los sistemas de recomendaci√≥n.\nFamiliarizaci√≥n con las t√©cnicas de filtrado colaborativo y basado en contenido.\nImplementaci√≥n de sistemas de recomendaci√≥n utilizando Python y la biblioteca de ciencia de datos de Pandas.\nEvaluaci√≥n del rendimiento de los sistemas de recomendaci√≥n.\n\n\n\nM√≥dulo 2: Series de Tiempo con Prophet\n\nIntroducci√≥n a las series de tiempo y sus aplicaciones en la ciencia de datos.\nFamiliarizaci√≥n con la biblioteca Prophet de Facebook para el an√°lisis de series de tiempo.\nImplementaci√≥n de t√©cnicas avanzadas de an√°lisis de series de tiempo, como la descomposici√≥n y la modelizaci√≥n de tendencias y estacionalidad.\nEvaluaci√≥n del rendimiento del modelo.\n\n\n\nM√≥dulo 3: Teor√≠a de Colas aplicado en Python\n\nIntroducci√≥n a la teor√≠a de colas y sus aplicaciones en la ciencia de datos.\nFamiliarizaci√≥n con las t√©cnicas avanzadas de an√°lisis de colas, como la ley de Little y la teor√≠a de colas de Jackson.\nImplementaci√≥n de modelos de teor√≠a de colas utilizando Python y la biblioteca de ciencia de datos de NumPy.\nEvaluaci√≥n del rendimiento del modelo.\n\n\n\nMetodolog√≠a y estructura del curso:\n\nEl curso tendr√° una duraci√≥n de un semestre.\nCada semana, se realizar√° un quiz corto para evaluar el progreso de los estudiantes.\nLos estudiantes trabajar√°n en un proyecto de ciencia de datos a lo largo del semestre.\nLa evaluaci√≥n ser√° con una proporci√≥n del 50% promedio de quiz y un 50% proyecto."
  },
  {
    "objectID": "data_science_ingemat/modulo2/prophet.html",
    "href": "data_science_ingemat/modulo2/prophet.html",
    "title": "Tema 3: Prophet",
    "section": "",
    "text": "Prophet es una biblioteca de Python desarrollada por Facebook que se utiliza para la predicci√≥n de series temporales. Prophet es especialmente √∫til para los casos de uso que tienen patrones estacionales fuertes y varias temporadas de datos hist√≥ricos. Prophet tambi√©n es robusto ante los datos faltantes y los cambios en la tendencia, y normalmente maneja bien los valores at√≠picos.\nLa biblioteca Prophet intenta capturar la tendencia y la estacionalidad al ajustar un modelo aditivo donde las observaciones no negativas se describen como la suma de los componentes. El objetivo de Prophet es hacer que las predicciones de series temporales sean escalables y automatizadas.\nA continuaci√≥n, enumeraremos y describiremos brevemente algunas de las principales funciones que ofrece la biblioteca Prophet.\n\n\n\nProphet(): Esta es la clase principal de la biblioteca Prophet. Se utiliza para crear un objeto de Prophet que luego se puede ajustar a los datos de la serie temporal y se utiliza para hacer predicciones.\nfit(): Este m√©todo se utiliza para ajustar el modelo Prophet a los datos de la serie temporal. Se debe llamar antes de hacer predicciones.\nmake_future_dataframe(): Este m√©todo se utiliza para crear un DataFrame de Pandas de fechas futuras para las cuales hacer predicciones.\npredict(): Este m√©todo se utiliza para hacer predicciones. Se puede llamar despu√©s de ajustar el modelo Prophet a los datos de la serie temporal.\nplot() y plot_components(): Estos m√©todos se utilizan para visualizar las predicciones y los componentes del modelo Prophet.\nadd_seasonality(): Este m√©todo se utiliza para agregar estacionalidad personalizada al modelo Prophet.\nadd_country_holidays(): Este m√©todo se utiliza para agregar las vacaciones de un pa√≠s espec√≠fico al modelo Prophet.\n\n\n\n\nCrea una jupyter notebook con una data sintetica u otra a elecci√≥n que simule una serie de tiempo. Usa cada funci√≥n expuesta anteriormente y comenta los resultados"
  },
  {
    "objectID": "data_science_ingemat/modulo2/prophet.html#tarea-2",
    "href": "data_science_ingemat/modulo2/prophet.html#tarea-2",
    "title": "Tema 3: Prophet",
    "section": "",
    "text": "Crea una jupyter notebook con una data sintetica u otra a elecci√≥n que simule una serie de tiempo. Usa cada funci√≥n expuesta anteriormente y comenta los resultados"
  },
  {
    "objectID": "data_science_ingemat/modulo2/proyecto2.html",
    "href": "data_science_ingemat/modulo2/proyecto2.html",
    "title": "Proyecto",
    "section": "",
    "text": "En este proyecto, se espera que apliquen sus conocimientos de series de tiempo y el uso de la biblioteca Prophet para realizar pron√≥sticos. Debe encontrar un conjunto de datos con m√°s de tres a√±os de historia para su an√°lisis.\n\n\n\n\nRealizar un an√°lisis exploratorio de los datos para entender las caracter√≠sticas de la serie de tiempo.\nPreprocesar los datos si es necesario para prepararlos para Prophet.\nEntrenar un modelo Prophet en los datos y realizar pron√≥sticos.\nEvaluar la precisi√≥n de sus pron√≥sticos.\nInterpretar los componentes de su modelo (tendencia, estacionalidad).\n\n\n\n\n\nAseg√∫rese de dividir sus datos en conjuntos de entrenamiento y prueba para evaluar la precisi√≥n de sus pron√≥sticos.\nConsidere la posibilidad de ajustar los hiperpar√°metros de Prophet para mejorar su modelo.\nRecuerde que Prophet puede manejar datos faltantes, pero debe decidir si imputar estos datos es la mejor opci√≥n para su situaci√≥n.\nLa entrega del proyecto debe realizarse a trav√©s de un repositorio de GitHub. Aseg√∫rese de que su proyecto est√© bien comentado, para esto use el archivo ReadMe.\nLa fecha l√≠mite para la entrega del proyecto es el lunes 31 de julio. Las presentaciones se llevar√°n a cabo hasta el 5 de agosto.\n\n\n\n\n\nCalidad del an√°lisis exploratorio de datos y las conclusiones extra√≠das.\nCorrecta aplicaci√≥n de Prophet y uso de sus funcionalidades.\nPrecisi√≥n de los pron√≥sticos.\nInterpretaci√≥n de los componentes del modelo.\nCalidad de la presentaci√≥n de sus resultados.\n\n\n\n\n\nAjuste de la flexibilidad de la tendencia con el par√°metro changepoint_prior_scale.\nAjuste de la estacionalidad con add_seasonality y seasonality_mode.\nUso de add_country_holidays para incluir efectos de vacaciones.\nUso de make_future_dataframe para generar fechas futuras para pron√≥sticos.\nInterpretaci√≥n de los componentes del modelo con plot_components."
  },
  {
    "objectID": "data_science_ingemat/modulo2/proyecto2.html#proyecto-de-series-de-tiempo-con-prophet",
    "href": "data_science_ingemat/modulo2/proyecto2.html#proyecto-de-series-de-tiempo-con-prophet",
    "title": "Proyecto",
    "section": "",
    "text": "En este proyecto, se espera que apliquen sus conocimientos de series de tiempo y el uso de la biblioteca Prophet para realizar pron√≥sticos. Debe encontrar un conjunto de datos con m√°s de tres a√±os de historia para su an√°lisis.\n\n\n\n\nRealizar un an√°lisis exploratorio de los datos para entender las caracter√≠sticas de la serie de tiempo.\nPreprocesar los datos si es necesario para prepararlos para Prophet.\nEntrenar un modelo Prophet en los datos y realizar pron√≥sticos.\nEvaluar la precisi√≥n de sus pron√≥sticos.\nInterpretar los componentes de su modelo (tendencia, estacionalidad).\n\n\n\n\n\nAseg√∫rese de dividir sus datos en conjuntos de entrenamiento y prueba para evaluar la precisi√≥n de sus pron√≥sticos.\nConsidere la posibilidad de ajustar los hiperpar√°metros de Prophet para mejorar su modelo.\nRecuerde que Prophet puede manejar datos faltantes, pero debe decidir si imputar estos datos es la mejor opci√≥n para su situaci√≥n.\nLa entrega del proyecto debe realizarse a trav√©s de un repositorio de GitHub. Aseg√∫rese de que su proyecto est√© bien comentado, para esto use el archivo ReadMe.\nLa fecha l√≠mite para la entrega del proyecto es el lunes 31 de julio. Las presentaciones se llevar√°n a cabo hasta el 5 de agosto.\n\n\n\n\n\nCalidad del an√°lisis exploratorio de datos y las conclusiones extra√≠das.\nCorrecta aplicaci√≥n de Prophet y uso de sus funcionalidades.\nPrecisi√≥n de los pron√≥sticos.\nInterpretaci√≥n de los componentes del modelo.\nCalidad de la presentaci√≥n de sus resultados.\n\n\n\n\n\nAjuste de la flexibilidad de la tendencia con el par√°metro changepoint_prior_scale.\nAjuste de la estacionalidad con add_seasonality y seasonality_mode.\nUso de add_country_holidays para incluir efectos de vacaciones.\nUso de make_future_dataframe para generar fechas futuras para pron√≥sticos.\nInterpretaci√≥n de los componentes del modelo con plot_components."
  },
  {
    "objectID": "data_science_ingemat/modulo2/proyecto2.html#r√∫brica-del-proyecto-de-series-de-tiempo-con-prophet",
    "href": "data_science_ingemat/modulo2/proyecto2.html#r√∫brica-del-proyecto-de-series-de-tiempo-con-prophet",
    "title": "Proyecto",
    "section": "R√∫brica del Proyecto de Series de Tiempo con Prophet",
    "text": "R√∫brica del Proyecto de Series de Tiempo con Prophet\n\n\n\n\n\n\n\n\n\n\nPuntos de Evaluaci√≥n\nNivel 1\nNivel 2\nNivel 3\nNivel 4\n\n\n\n\nCalidad del an√°lisis exploratorio de datos y las conclusiones extra√≠das\nEl an√°lisis exploratorio de datos es inexistente o muy limitado, sin conclusiones significativas.\nEl an√°lisis exploratorio de datos es b√°sico, con algunas conclusiones pero falta profundidad o comprensi√≥n completa de los datos.\nEl an√°lisis exploratorio de datos es s√≥lido, con conclusiones bien razonadas y una buena comprensi√≥n de los datos.\nEl an√°lisis exploratorio de datos es excepcionalmente detallado y perspicaz, con conclusiones profundas y una comprensi√≥n completa de los datos.\n\n\nCorrecta aplicaci√≥n de Prophet y uso de sus funcionalidades\nProphet no se utiliza correctamente o no se utiliza en absoluto.\nProphet se utiliza de manera b√°sica, pero no se explotan todas sus funcionalidades.\nProphet se utiliza correctamente y se explotan la mayor√≠a de sus funcionalidades.\nProphet se utiliza de manera experta, aprovechando todas sus funcionalidades para mejorar el modelo.\n\n\nPrecisi√≥n de los pron√≥sticos\nLos pron√≥sticos son inexactos y el modelo no se ajusta bien a los datos.\nLos pron√≥sticos son moderadamente precisos, pero el modelo podr√≠a mejorarse.\nLos pron√≥sticos son precisos y el modelo se ajusta bien a los datos.\nLos pron√≥sticos son extremadamente precisos y el modelo se ajusta excepcionalmente bien a los datos.\n\n\nInterpretaci√≥n de los componentes del modelo\nNo se realiza ninguna interpretaci√≥n de los componentes del modelo.\nSe realiza una interpretaci√≥n b√°sica de algunos componentes del modelo.\nSe realiza una interpretaci√≥n s√≥lida de la mayor√≠a de los componentes del modelo.\nSe realiza una interpretaci√≥n detallada y perspicaz de todos los componentes del modelo.\n\n\nCalidad de la presentaci√≥n de sus resultados\nLos resultados no se presentan de manera clara o comprensible.\nLos resultados se presentan de manera b√°sica, pero podr√≠an mejorarse para una mayor claridad o comprensi√≥n.\nLos resultados se presentan de manera clara y comprensible.\nLos resultados se presentan de manera excepcionalmente clara, detallada y comprensible."
  },
  {
    "objectID": "data_science_ingemat/modulo2/estacionaria.html",
    "href": "data_science_ingemat/modulo2/estacionaria.html",
    "title": "Tema 2: Estacionariedad",
    "section": "",
    "text": "Una serie de tiempo es considerada estacionaria si cumple con las siguientes propiedades estad√≠sticas a lo largo del tiempo:\n\nTiene una media constante.\nTiene una varianza constante.\nLa covarianza entre los dos periodos (por ejemplo, t y t+m) depende solo de la diferencia m y no del tiempo t.\n\nFormalmente, una serie de tiempo {Xt} se considera estrictamente estacionaria si la distribuci√≥n conjunta de (Xt1, Xt2, ‚Ä¶, Xtk) es la misma que la de (Xt1+h, Xt2+h, ‚Ä¶, Xtk+h) para cualquier elecci√≥n de los tiempos t1, t2, ‚Ä¶, tk y para cada desplazamiento h.\n\n\nExisten varias t√©cnicas para determinar si una serie de tiempo es estacionaria. Algunas de las m√°s populares incluyen:\n\nPrueba de Dickey-Fuller aumentada (ADF): Esta prueba hipotetiza que una serie de tiempo es no estacionaria (tiene alguna forma de ra√≠z unitaria). Un resultado de prueba que rechaza esta hip√≥tesis indica que la serie es estacionaria.\nPrueba de KPSS (Kwiatkowski-Phillips-Schmidt-Shin): A diferencia de la prueba ADF, la prueba KPSS hipotetiza que una serie de tiempo es estacionaria. Un resultado de prueba que rechaza esta hip√≥tesis indica que la serie no es estacionaria.\n\n\n\n\nLa prueba de Dickey-Fuller Aumentada es una prueba de ra√≠z unitaria en la presencia de estructura de serie autocorrelacionada. Para una serie de tiempo \\(y_t\\), la versi√≥n b√°sica de la prueba de Dickey-Fuller considera la siguiente regresi√≥n de primer orden:\n\\(Œîy_t = Œ± + Œ≤t + Œ≥y_{t-1} + Œµ_t\\)\nLa hip√≥tesis nula es que \\(Œ≥ = 0\\) (la serie tiene una ra√≠z unitaria), mientras que la alternativa es \\(Œ≥ &lt; 0\\) (la serie es estacionaria). Para la versi√≥n aumentada de la prueba, se agregan t√©rminos de rezago de la serie diferenciada a la derecha de la ecuaci√≥n de regresi√≥n para eliminar la autocorrelaci√≥n en los errores (\\(Œµ_t\\)):\n\\(Œîy_t = Œ± + Œ≤t + Œ≥y_{t-1} + Œ¥1Œîy_{t-1} + ‚Ä¶ + Œ¥_{p-1}Œîy_{t-p+1} + Œµ_t\\)\n\n\n\nLa prueba KPSS es una prueba de hip√≥tesis para probar la estacionariedad de una serie de tiempo (hip√≥tesis nula) contra la presencia de una ra√≠z unitaria (hip√≥tesis alternativa).\nPara una serie de tiempo \\(y_t\\), la prueba KPSS considera la siguiente ecuaci√≥n de regresi√≥n:\n\\(y_t = Œ± + Œ≤t + St + Œµ_t\\)\ndonde \\(St\\) es una caminata aleatoria, que puede ser estoc√°stica o determin√≠stica.\nLa hip√≥tesis nula es que la serie es estacionaria (o trend-estacionaria), mientras que la alternativa es que la serie tiene una ra√≠z unitaria.\n\n\n\nSerie Estacionaria: Las variaciones diarias de la temperatura (alrededor de la media) podr√≠an ser consideradas como una serie estacionaria, ya que podr√≠amos esperar que la variaci√≥n media en la temperatura no cambie mucho de un d√≠a a otro.\nSerie No Estacionaria: El precio de una acci√≥n en el mercado es un ejemplo de una serie no estacionaria, ya que tiende a seguir una tendencia ascendente o descendente y no oscila alrededor de una constante.\n\nPara implementar pruebas de estacionariedad en Python, puedes usar la biblioteca statsmodels."
  },
  {
    "objectID": "data_science_ingemat/modulo2/estacionaria.html#series-de-tiempo-estacionarias",
    "href": "data_science_ingemat/modulo2/estacionaria.html#series-de-tiempo-estacionarias",
    "title": "Tema 2: Estacionariedad",
    "section": "",
    "text": "Una serie de tiempo es considerada estacionaria si cumple con las siguientes propiedades estad√≠sticas a lo largo del tiempo:\n\nTiene una media constante.\nTiene una varianza constante.\nLa covarianza entre los dos periodos (por ejemplo, t y t+m) depende solo de la diferencia m y no del tiempo t.\n\nFormalmente, una serie de tiempo {Xt} se considera estrictamente estacionaria si la distribuci√≥n conjunta de (Xt1, Xt2, ‚Ä¶, Xtk) es la misma que la de (Xt1+h, Xt2+h, ‚Ä¶, Xtk+h) para cualquier elecci√≥n de los tiempos t1, t2, ‚Ä¶, tk y para cada desplazamiento h.\n\n\nExisten varias t√©cnicas para determinar si una serie de tiempo es estacionaria. Algunas de las m√°s populares incluyen:\n\nPrueba de Dickey-Fuller aumentada (ADF): Esta prueba hipotetiza que una serie de tiempo es no estacionaria (tiene alguna forma de ra√≠z unitaria). Un resultado de prueba que rechaza esta hip√≥tesis indica que la serie es estacionaria.\nPrueba de KPSS (Kwiatkowski-Phillips-Schmidt-Shin): A diferencia de la prueba ADF, la prueba KPSS hipotetiza que una serie de tiempo es estacionaria. Un resultado de prueba que rechaza esta hip√≥tesis indica que la serie no es estacionaria.\n\n\n\n\nLa prueba de Dickey-Fuller Aumentada es una prueba de ra√≠z unitaria en la presencia de estructura de serie autocorrelacionada. Para una serie de tiempo \\(y_t\\), la versi√≥n b√°sica de la prueba de Dickey-Fuller considera la siguiente regresi√≥n de primer orden:\n\\(Œîy_t = Œ± + Œ≤t + Œ≥y_{t-1} + Œµ_t\\)\nLa hip√≥tesis nula es que \\(Œ≥ = 0\\) (la serie tiene una ra√≠z unitaria), mientras que la alternativa es \\(Œ≥ &lt; 0\\) (la serie es estacionaria). Para la versi√≥n aumentada de la prueba, se agregan t√©rminos de rezago de la serie diferenciada a la derecha de la ecuaci√≥n de regresi√≥n para eliminar la autocorrelaci√≥n en los errores (\\(Œµ_t\\)):\n\\(Œîy_t = Œ± + Œ≤t + Œ≥y_{t-1} + Œ¥1Œîy_{t-1} + ‚Ä¶ + Œ¥_{p-1}Œîy_{t-p+1} + Œµ_t\\)\n\n\n\nLa prueba KPSS es una prueba de hip√≥tesis para probar la estacionariedad de una serie de tiempo (hip√≥tesis nula) contra la presencia de una ra√≠z unitaria (hip√≥tesis alternativa).\nPara una serie de tiempo \\(y_t\\), la prueba KPSS considera la siguiente ecuaci√≥n de regresi√≥n:\n\\(y_t = Œ± + Œ≤t + St + Œµ_t\\)\ndonde \\(St\\) es una caminata aleatoria, que puede ser estoc√°stica o determin√≠stica.\nLa hip√≥tesis nula es que la serie es estacionaria (o trend-estacionaria), mientras que la alternativa es que la serie tiene una ra√≠z unitaria.\n\n\n\nSerie Estacionaria: Las variaciones diarias de la temperatura (alrededor de la media) podr√≠an ser consideradas como una serie estacionaria, ya que podr√≠amos esperar que la variaci√≥n media en la temperatura no cambie mucho de un d√≠a a otro.\nSerie No Estacionaria: El precio de una acci√≥n en el mercado es un ejemplo de una serie no estacionaria, ya que tiende a seguir una tendencia ascendente o descendente y no oscila alrededor de una constante.\n\nPara implementar pruebas de estacionariedad en Python, puedes usar la biblioteca statsmodels."
  },
  {
    "objectID": "data_science_ingemat/modulo2/estacionaria.html#tarea-1-jupyter-notebook",
    "href": "data_science_ingemat/modulo2/estacionaria.html#tarea-1-jupyter-notebook",
    "title": "Tema 2: Estacionariedad",
    "section": "Tarea 1: Jupyter Notebook",
    "text": "Tarea 1: Jupyter Notebook\nAhora debes poner manos a la obra y completar el siguiente notebook: Notebook 1 de Series de Tiempo"
  }
]